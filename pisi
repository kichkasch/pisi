#!/usr/bin/env python

"""
    Copyright 2008 Esben Damgaard <ebbe at hvemder . dk>


    This file is part of Pisi.

    Pisi is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Pisi is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Pisi.  If not, see <http://www.gnu.org/licenses/>.
"""

import ConfigParser
import os
import sys
import datetime

from events import events


modulesToLoad = []
modulesNamesCombined = ""
verbose = False
# soft = True means that the program shouldn't make any changes on servers
soft = False

def parseArguments ():
	global verbose, modulesNamesCombined, soft
	for arg in sys.argv[1:]:
		if arg[:1]!='-':
			modulesToLoad.append( arg )
			modulesNamesCombined += arg
		elif arg=='-v' or arg=='--verbose':
			verbose=True
			print "Verbose mode on"
		elif arg=='-s' or arg=='--soft':
			soft = True
		elif arg=='-c' or arg=='--list-configurations':
			list_configurations()
	if len(modulesToLoad)!=2:
		usage()
	modulesToLoad.sort() # We sort them, so id's made from the names will 
								# always be the same (will make sense later on)

def usage ():
	usage = """You start the program by specifying 2 modules to synchronize.
Like this:
  ./pisi [option] google isc
Flags:
  -v --verbose
      Make program verbose
  -s --soft
      Don't actually make any changes on the servers/in the files
  -c --list-configurations
      List which configurations there are in the config-file (this don't need 
      the two modules)
"""
	sys.exit(usage)
def list_configurations ():
	# Read configuration
	homedir = os.environ.get('HOME')
	configfolder = homedir + '/.pisi/'
	configfile = configfolder + 'conf'
	if not os.path.isfile(configfile):
		sys.exit("Couldn't find the configuration file: "+configfile)
	config = ConfigParser.ConfigParser()
	config.readfp(open(configfile))
	print 'You seem to have these configurations:'
	for con in config.sections():
		print '\t',con,'which uses module',config.get(con,'module')
	sys.exit(0)

def main ():
	global verbose,soft
	# Read configuration
	homedir = os.environ.get('HOME')
	configfolder = homedir + '/.pisi/'
	configfile = configfolder + 'conf'
	if verbose:
		print "Reading configfile:",configfile
	if not os.path.isfile(configfile):
		sys.exit("Couldn't find the configuration file: "+configfile)
	config = ConfigParser.ConfigParser()
	config.readfp(open(configfile))

	"""
	Now configuration can be read like this
	print config.get('google','user')
	"""
	
	# Create folders for the modules to use to save stuff
	modulesFolder = configfolder+modulesToLoad[0]+modulesToLoad[1]+'/'
	if not os.path.exists(modulesFolder):
		os.mkdir( modulesFolder )
	# Import modules
	source = []
	for i in range(0,2):
		modulename = config.get(  modulesToLoad[i], 'module' )
		if not os.path.exists(modulesFolder + modulesToLoad[i]):
			os.mkdir( modulesFolder + modulesToLoad[i] )
		exec "from modules import " + modulename + " as module"+i.__str__()
		exec "source.append( module"+i.__str__()+".SynchronizationModule(modulesNamesCombined, config, modulesToLoad[i], modulesFolder+modulesToLoad[i]+'/', verbose, soft) )"
	# Now we have source[0] and source[1] as our 2 synchronization modules

	"""
	# When were these two last updated:
	lastSync = lastSynchronization( configfolder, modulesToLoad[0]+modulesToLoad[1] )
	for i in source:
		i.initChangesSince( lastSync )
	"""
	
	# Get all events
	allEvents = [ source[0].allEvents() , source[1].allEvents() ]
	if verbose:
		print 
		print "Module",modulesToLoad[0],"has",len(allEvents[0].getAllEvents()),"events in total"
		print "Module",modulesToLoad[1],"has",len(allEvents[1].getAllEvents()),"events in total"
		print 
	# Loop through all events from source[0]
	for id,event in allEvents[0].getAllEvents().iteritems():
		if verbose:
			print "Checking eventid",id,"from module",modulesToLoad[0]
		# Does it exist in the other module? Did it ever?
		if not event.commonid:
			# This event has never been synchronized
			if verbose:
				print "\tThis event has never been synchronized"
				print "\tAdd",event.id,"to module",modulesToLoad[1]
			event.commonid = event.id # 'Steal' the id as the common id
			# Update commonid
			source[0].addCommonid( event.id, event.commonid )
			# Add event
			source[1].addEvent( event )
		else:
			sameEvent = allEvents[1].getEvent(event.commonid)
			if not sameEvent==False:
				# They have the same event
				if verbose:
					print "\tThey both have this event"
				# See if they have different updatetimes
				"""if event.updated != sameEvent.updated:
					if verbose:
						print "\t one is newer than the other. I'll try an merge them"
					merged = event.merge( sameEvent )
					if verbose:
						merged.prettyPrint()
					merged.id = id
					source[0].replaceEvent( id, merged )
					merged.id = sameEvent.id
					source[1].replaceEvent( sameEvent.id, merged )"""
				
				if event.updated < sameEvent.updated:
					print "modul 2 er nyest"
					source[0].replaceEvent( event.id, sameEvent )
				elif event.updated > sameEvent.updated:
					print "modul 1 er nyest"
					event.id = sameEvent.id
					source[1].replaceEvent( sameEvent.id, event )
				
				# Remove event from our temporary list from source[1]
				allEvents[1].removeEvent( sameEvent.commonid )
			else:
				# Event has been deleted from source[1]
				# so delete it from source[0]
				source[0].removeEvent( event.id )
				
		print ""
	
	# Loop through all remaning events from source[1]
	for id,event in allEvents[1].getAllEvents().iteritems():
		if verbose:
			print "Checking eventid",id,"from module",modulesToLoad[0]
		# Does it exist in the other module? Did it ever?
		if not event.commonid:
			# This event has never been synchronized
			print "\tThis event has never been synchronized"
			if verbose:
				print "\tAdd",event.id,"to module",modulesToLoad[1]
			event.commonid = event.id # 'Steal' the id as the common id
			# Update commonid
			source[1].addCommonid( event.id, event.commonid )
			# Add event
			source[0].addEvent( event )
		else:
			# Event has been deleted from source[0]
			# so delete it from source[1]
			source[1].removeEvent( event.id )
	
	source[0].saveModifications()
	source[1].saveModifications()
	

if __name__ == "__main__":
	# Testing
	#sys.argv = ['file', '--verbose', 'googleTest','googleTest2']#, 'zdummy']
	
	parseArguments()
	main()
	
